/*! \mainpage Evolutionary algorithm framework.
 * \section intro_sec Introduction
 * This framework implements the definition of a chromosome class as well as the evolutionary algorithm class. The first one is developed in order to ease the implementation
 * of the second one and abstract some of the needed algorithms. The framework uses the gnuplot libraries to output a graph of the fitness function live while evolving so
 * that the user can have a feedback of how the algorithm is performing. Also, for implementing the option of a multithreaded evolution the
 * <a href="threadpool libraries">http://threadpool.sourceforge.net/</a> from boost.
 *
 * \section usage Usage
 * An example of the usage of the library can be found in main.cpp.
 */

/** \file ea.h
 * Evolutionary algorithm class library containing the definitions.
 */

/** \file ea.cpp
 * File containing the implementations of the evolutionary algorithm class library.
 */

/** \file main.cpp
 * Usage example of the class.
 */

#ifndef EA_H
#define EA_H

#include <iostream>
#include <vector>
#include <random>
#include <chrono>
#include <limits>
#include <algorithm>
#include "gnuplot-iostream.h"
#include <tuple>
#include <fstream>
#include <algorithm>
#include <boost/thread/mutex.hpp>
#include <boost/bind.hpp>
#include <boost/threadpool.hpp>
#include <functional>


template<class T>
class EA;


/** Types of encoding for the chromosome.
 *
 * Enum containing the 3 types of encoding that can be used for the chromosomes.
 */
enum encoding_type {
    BINARY, //!< Encoding consisting in strings of zeroes and ones.
    PERMUTATION, //!< Encoding consisting in strings of numbers that represent a sequence.
    VALUE, //!< Encoding consisting in strings of numbers, characters or whatever.
};

/** Types of crossover for the chromosomes.
 *
 * Enum containing the 3 types of crossover that can be used for the breeding of the new generation of chromosomes.
 */
enum crossover_type {
    SINGLE_POINT, //!< The parent chromosomes are split in two and the offspring is generated by taking the beginning of one an the end of the other. The second offspring is done the other way around.
    TWO_POINT, //!< The parent chromosomes are split in three and the offspring is generated by taking the beginning and end of one and the middle of the oder. The second offspring is done the other way around.
    UNIFORM_CROSSOVER, //!< A random mask is generated and the offspring is generated taking values from one parent if the mask is 0 and from the other if it is 1. The second offspring is done the other way around.
    FLAT, //!< The offspring is generated with a combination of the value from both parents based on a random value generated.
};

/** Types of mutation for the chromosomes.
 *
 * Enum containing the 6 types of mutation that can be used to modify the chromosomes.
 */
enum mutation_type {
    BIT_STRING, //!< The probability of a bit of the string to be inverted depends on the length of the string.
    FLIP_BIT, //!< The whole string is inverted.
    BOUNDARY, //!< The values of the string are replaced, given a certain probability, with the upper or lower boundary values.
    NON_UNIFORM, //!< The values of the string are replaced, given a probability decreasing with the increasing of generations, with a random value in between the boundaries.
    UNIFORM, //!< The values of the string are replaced, given a certain probability, with a random value in between the boundaries.
    GAUSSIAN, //!< A value obtained from a gaussian distribution (0.0, 1.0) is added to the values of the chromosomes. The value is then clipped to stay inside the boundaries.
};

/** Types of selection for the chromosomes.
 *
 * Enum containing the 3 types of selection that can be used to choose the parents of the next generation.
 */
enum selection_type {
    ROULETTE, //!< The probability of a chromosome to be chosen depends directly on its fitness value.
    RANK, //!< The chromosomes are assigned a rank value corresponding to the percentage of the total fitness value of the generation they contribute to. Then a random one is chosen, with a bigger probability the bigger the rank.
    TOURNAMENT, //!< Random chromosomes are picked up and the best of them is chosen.
};

/** Types of replacement.
 *
 * Enum containing the 3 types of replacement that can be used to put the offspring into the new generation.
 */
enum replacement_type {
    GENERATIONAL, //!< The parents are replaced by the offspring they generated.
    STEADY_STATE, //!< The parents are replaced by the offspring only if the offspring is better.
    ELITISM, //!< The worst chromosomes from the population are replaced by the offspring.
};

/**
 * Definition of the chromosome class.
 *
 * This class defines the individual chromosome that is then used inside the EA class to create the genetic algorithm. It includes the different mutation types.
 * The class accepts a template T to be able to define Chromosomes that are either int, float, double or whatever.
 */
template <class T>
class Chromosome {
    /**
     * Definition of the class EA as a friend to allow it to access the protected parameters.
     */
    friend class EA<T>;

protected:
    std::vector<T> chromosome_values; //!< Array containing the values of the chromosome.
    T lower_boundary; //!< Maximum value allowed for the chromosome.
    T upper_boundary; //!< Minimum value allowed for the chromosome.
    unsigned int size; //!< Size of the chromosome. (Length of #chromosome_values.)
    bool evaluated; //!< Boolean stating if the chromosome has been asigned a fitness value or not.
    double fitness_value; //!< Fitness value of the chromosome.
    encoding_type chromosome_encoding; //!< Chromosome encoding chosen from the #encoding_type enum.
    std::default_random_engine generator; //!< Pseudo-random generator used for generating random variables.

public:
    /**
     * Class constructor
     * @param chromosome_encoding Encoding used for the chromosomes. Chosen from the #encoding_type enum.
     * @param min Minimum value allowed for the chromosome.
     * @param max Maximum value allowed for the chromosome.
     */
    Chromosome(encoding_type chromosome_encoding, T min, T max);

    /**
     * Default constructor with some default values.
     */
    Chromosome();

    /**
     * Copy constructor. Creates a new choromosome based on the one given.
     * @param chromosome_copy The choromosome to copy from.
     */
    Chromosome(const Chromosome& chromosome_copy);

    /**
     * Copy all the parameters from one cromosome to another.
     * @param chromosome_copy The chromosome to copy the parameters from.
     * @return The copied chromosome.
     */
    Chromosome<T>& operator=(const Chromosome& chromosome_copy);

    /**
     * Default destructor.
     */
    ~Chromosome();

    /**
     * Method that allows to write the chromosome values. The size of the chromosome is the size of the input vector.
     * @param values Vector containing the desired values for the chromosome.
     */
    void setChromosome(std::vector<T> values);

    /**
     * Method that allows to write the chromosome values. The size of the chromosome is given as a parameter.
     * @param values Array containing the desired values for the chromosome.
     * @param size Size of the given array.
     */
    void setChromosome(T values[], int size);

    /**
     * Method that returns the chromosome values.
     * @return Array containing the values of the chromosome.
     */
    std::vector<T> getChromosome();

    /**
     * Method that copies the chromosome into a given vector.
     * @param chromosmome_values The vector to copy the choromosome_values in.
     */
    void copyChromosome(std::vector<T>& chromosome_values);

    /**
     * Method that allows to write the fitness value of the chromosome.
     * @param value Double containing the fitness value.
     */
    void setFitness(double value);

    /**
     * Method that states if the fitness value of the chromosome has been set.
     * @return True if the fitness value has been set. False otherwise.
     */
    bool isEvaluated();

    /**
     * Method that returns the fitness value of the chromosome.
     * @return Double containing the fitness value.
     */
    double getFitness();

    /**
     * Method that performs a bit string mutation of the chromosome as described in #mutation_type.
     */
    void bitStringMutation();

    /**
     * Method that performs a flip bit mutation of the chromosome as described in #mutation_type.
     */
    void flipBitMutation();

    /**
     * Method that performs a boundary mutation of the chromosome as described in #mutation_type.
     * @param rate Probability of the mutation to occur. Double in between 0.0 and 1.0, being 1.0 always mutate.
     */
    void boundaryMutation(double rate);

    /**
     * Method that performs an uniform mutation of the chromosome as described in #mutation_type.
     * @param rate Probability of the mutation to occur. Double in between 0.0 and 1.0, being 1.0 always mutate.
     */
    void uniformMutation(double rate);

    /**
     * Method that performs a gaussian mutation of the chromosome as described in #mutation_type.
     * @param rate Probability of the mutation to occur. Double in between 0.0 and 1.0, being 1.0 always mutate.
     */
    void gaussianMutation(double rate);

    /**
     * Method that prints the chromosome values separated with a space.
     */
    void printChromosome();
};

/**
 * Function used to compare the chromosomes given their fitness values. It is used with the sort function to be able to order vectors
 * of chromosomes. It orders them in increasing fitness value.
 * @param A Chromosome A.
 * @param B Chromosome B.
 * @return True if the fitness value of A is smaller than the one of B. False otherwise.
 */
template <class T>
bool ChromosomeComp(Chromosome<T>* A, Chromosome<T>* B);

/**
 * Function used to compare the chromosomes given their fitness values. It is used with the sort function to be able to order vectors
 * of chromosomes. It orders them in decreasing fitness value.
 * @param A Chromosome A.
 * @param B Chromosome B.
 * @return True if the fitness value of A is bigger than the one of B. False otherwise.
 */
template <class T>
bool ChromosomeCompInv(Chromosome<T>* A, Chromosome<T>* B);

/**
 * Definition of the EA class.
 *
 * Class able to perform the evolution of a population of chromosomes. It accepts the template T to allow the chromosomes to be either int, float, double or whatever. \todo Add an specialization for boolean.
 */
template <class T>
class EA {
protected:
    std::vector<Chromosome<T>*> population; //!< Vector containing pointers all the chromosomes for the actual population.
    std::vector<Chromosome<T>*> selected; //!< Vector containing pointers to the selected chromosomes for crossover.
    std::vector<Chromosome<T>*> offspring; //!< Vector containing pointers to the chromosomes resultant of the crossover.

    unsigned int population_size; //!< Size of the population.
    unsigned int Chromosome_size; //!< Length of the chromosomes.
    encoding_type encoding; //!< Chromosome encoding method chosen from the #encoding_type enum.
    crossover_type crossover; //!< Chromosome crossover method chosen from the #crossover_type enum.
    mutation_type mutation; //!< Chromosome mutation method chosen from the #mutation_type enum.
    selection_type selection; //!< Chromosome selection method chosen from the #selection_type enum.
    replacement_type replacement; //!< Chromosome replacement method chosen from the #replacement_type enum.
    T lower_boundary; //!< Minimum value allowed for the chromosomes.
    T upper_boundary; //!< Maximum value allowed for the chromosomes.
    double mutation_rate; //!< Mutation rate for the chromosomes.
    unsigned int selection_size; //!<Amount of chromosomes to be selected in the selection phase.
    double crossover_rate; //!< Crossover rate for the selected chromosomes.
    bool pre_breeding;

    unsigned int generation; //!< Number of the current generation.

    std::ofstream fitnessFile;

    double (*fitnessFunction)(Chromosome<T>*); //!< Pointer to the fitness function defined by the user. It has to return a double and accept a pointer to a chromosome.

    std::default_random_engine generator; //!< Pseudo-random generator used for generating random variables.

    std::vector<std::pair<double, double> > fitnessValuesMax; //!< Vector of paired values used for plotting the fitness function.
    std::vector<std::pair<double, double> > fitnessMean;

    boost::threadpool::fifo_pool tp;

public:
    bool plot_live; //!< Bool to configure if the GA plots the fitness function live or not.

    /**
     * Class constructor.
     * @param population Size of the population.
     * @param size Size of the chromosomes.
     * @param chromosome_encoding Encoding method of the chromosomes chosen from #encoding_type.
     * @param min Minimum value allowed for the chromosomes.
     * @param max Maximum value allowed for the chromosomes.
     * @param crossover Crossover method of the chromosomes chosen from #crossover_type.
     * @param crossover_rate Probability in between 0 and 1 that the crossover occurs.
     * @param mutation Mutation method of the chromosomes chosen from #mutation_type.
     * @param mutation_rate Probability in between 0 and 1 that the mutation occurs.
     * @param selection Selection method of the chromosomes chosen from #selection_type.
     * @param selection_size Amount of chromosomes to be selected for the crossover. It has to be an even number.
     * @param replacement Replacement method of the chromosomes chosen from #replacement_type.
     */
    EA(int population, int size, encoding_type chromosome_encoding, T min, T max, crossover_type crossover, double crossover_rate, mutation_type mutation, double mutation_rate, selection_type selection, int selection_size, replacement_type replacement, bool pre_breeding);

    EA(std::string file);

    /**
     * Default destructor.
     */
    ~EA();

    /**
     * Method that sets the fitness function with which the chromosomes are evaluated.
     *
     * @param function Pointer to a function defined by the user. It has to return a double and accept a pointer to a chromosome.
     */
    void setFitnessFunction(double (*function)(Chromosome<T>*));

    /**
     * Method that set the fitness function with which the chromosomes are evaluated.
     * @param function Pointer to a function defined by the user. It has to return a double and accept a pointer to a chromosome, the number of arguments passed to the main program and the array of arguments.
     * \attention This method is not implemented yet. However the definition is done for future development.
     */
    void setFitnessFunction(double (*function)(Chromosome<T>*, int argc, char** argv));

    /**
     * Method that initialized the population of chromosomes randomly.
     */
    void randomInitialization();

    /**
     * Method that initializes the population of chromosomes with some given ones.
     * @param initial_population Vector of the same size of the population defined in the constructor. It contains pointers to chromosomes.
     */
    void initializePopulation(std::vector<Chromosome<T>*> initial_population);

    /**
     * Method that prints the chromosomes of the population with their values.
     */
    void printPopulation();

    /**
     * Method that sets the fitness value of the chromosomes in the population that haven't been evaluated yet.
     */
    void evaluate();

    /**
     * Method that sets the fitness value of the chromosomes of the offspring.
     */
    void evaluateOffspring();

    /**
     * Method that sets the fitness value of the chromosomes in the population that haven't been evaluated yet using multithreading.
     * @param threads Number of threads to be used.
     */
    void evaluateThreaded(unsigned int threads);

    /**
     * Method that sets the fitness value of the chromosomes of the offspring using multithreading.
     * @param threads Number of threads to be used.
     */
    void evaluateOffspringThreaded(unsigned int threads);

    /**
     * Method that recieves a pointer to a chromosome and returns its fitness value using the function stored in EA::fitnessFunction.
     * @param i Pointer to the chromosome to be evaluated.
     * @return Double containing the fitness value of the chromosome.
     */
    double evaluateOne(Chromosome<T> *i);

    void preBreeding();

    /**
     * Method that selects the amount of chromosomes set by EA::selection_size with the method defined by EA::selection_type.
     * It removes them from the EA::population vector and stores them in the EA::selected vector.
     */
    void select();

    /**
     * Method that performs the crossover of the chromosomes stored in the EA::selected vector with the method defined in EA::crossover_type.
     * The produced offspring is mutated and stored in the EA::offspring vector.
     */
    void reproduce();

    /**
     * Method that fills the population with the chromosomes from the EA::selected vector and the EA::offspring vector depending on the method
     * defined by EA::replacement_type.
     */
    void replace();

    /**
     * Method that performs the evolution of the population until a certain fitness value is achieved or a number of generations has passed.
     * @param generations Maximum number of generations allowed.
     * @param solution Expected fitness value.
     * \deprecated It is desired to use the other two evolution methods since this one is outdated. It is expected to be updated soon and also
     * to include an option with multithreading.
     */
    void evolve(unsigned int generations, int solution);

    /**
     * Method that performs the evolution of the population for a certain number of generations.
     * @param generations Number of generations to evolve.
     * @return Pointer to the best chromosome of the population after the evolution.
     */
    Chromosome<T>* evolve(unsigned int generations);

    /**
     * Method that performs the evolution of the population for a certain number of generations with multithreading.
     * @param generations Number of generations to evolve.
     * @param threads Number of threads to use.
     * @return Pointer to the best chromosome of the population after the evolution.
     * \bug After around 3500 generations the program hangs and doesn't evolve anymore.
     */
    Chromosome<T>* evolveThreaded(unsigned int generations, unsigned int threads);

    bool checkpoint(std::string file_name);
};

#include "ea.cpp"

#endif
